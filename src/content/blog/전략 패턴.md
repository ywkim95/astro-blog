---
title: '전략 패턴'
description: '디자인 패턴 중 전략 패턴에 대해서 간단히 정리한 내용입니다'
pubDate: '2025-10-21'
heroImage: '/attachments/strategy-placeholder.png'
author: '김영우'
tags: ["design pattern", "strategy", "policy"]
---
# Chapter 1.1.3 전략 패턴

- 책 제목: 면접을 위한 CS 전공지식  노트
- 발표일: 2025년 10월 21일
- 주요 개념: 디자인패턴
- 챕터/페이지: 1장

# 정의

- 런타임 중 알고리즘 전략을 선택하여 객체 동작을 실시간으로 바뀌도록 할 수 있게 하는 디자인 패턴
- 알고리즘  변형이 빈번하게 필요한 경우 적합
- 정책 패턴(Strategy Pattern)은 정책 패턴(Policy Pattern)으로도 불림

![strategy-pattern.png](/attatchments/strategy-pattern.png)

- 여러가지 예시가 있겠지만 결제 시스템, 교통 수단, 요리 방식, 심지어 컵으로도 비유를 할 수 있음

### 결제 시스템 예시

```tsx
interface PaymentStrategy {
	pay(amount: number): void;
}

class CreditCardPayment implements PaymentStrategy {
	private cardNumber: string;
	private cvv: string;
	
	constructor(cardNumber: string, cvv: string) {
		this.cardNumber = cardNumber;
		this.cvv = cvv;
	}
	
	pay(amount: number) {
		console.log("CreditCard Payment!");
		// 실제 구현 코드...
	}
}

class KakaoPayment implements PaymentStrategy {
	private phoneNumber: string;
	
	constructor() {
		this.phoneNumber = phoneNumber;
	}
	
	pay(amount: number) {
		console.log("Kakao Payment!");
		// 실제 구현 코드...
	}
}

class ShoppingCart {
	private paymentStrategy : PaymentStrategy | null = null;
	
	setPaymentStrategy(strategy: PaymentStrategy): void {
		this.paymentStrategy = strategy;
	}
	
	checkout(amount: number): void {
		if(!this.paymentStrategy) {
			throw new Error('결제 방식을 선택해주세요');
		}
		
		this.paymentStrategy.pay(amount);
		console.log("결제 완료!");
	}
}

const cart = new ShoppingCart();
cart.setPaymentStrategy(new CreditCardPayment('1234-5678-9012-3456', '111'));
cart.checkout(100_000);
```

### 컵 전략 예시

```tsx
interface Drinktrategy {
	drink(amount: number): void;
}

class WaterDrink implements DrinkStrategy {
	private capacity: number;
	constructor(capacity: number) {
		this.capacity = capacity;
	}
	
	drink(amount: number) {
		console.log("drinks water!");
		this.capacity -= amount;
	}
}

class OrangeJuiceDrink implements DrinkStrategy {
	private capacity: number;
	private tasty: string;
	
	constructor(capacity:number, tasty:string) {
		this.capacity = capacity;
		this.tasty = tasty;
	}
	
	drink(amount: number) {
		console.log("drinks orange juice!");
		this.capacity -= amount;
		console.log(`this is ${tasty}`);
	}
}

class Cup {
	private drinkStrategy: DrinkStrategy | null = null;
	
	fill(drink: DrinkStrategy) {
		this.drinkStrategy = drink;
	}
	
	drinkBeverage(amount: number) {
		this.drinkStrategy.drink(amount);
	}
}

const cup = new Cup();
cup.fill(new WaterDrink(100));
cup.drinkBeverage(100);

cup.fill(new OrangeJuiceDrink(300, 'Good'));
cup.drinkBeverage(300);
```

## 장점

1. 개방-폐쇄 원칙(OCP)
    - 기존 코드 수정 없이 새로운 전략 추가 가능
    - 새로운 전략을 추가해도 기존 코드는 안전
2. 런타임에 전략 변경 가능
    - 실행 중에 동적으로 전략 교체
    - 사용자가 전략을 자유롭게 선택
3. 단일 책임 원칙(SRP)
    - 각 전략이 하나의 알고리즘만 담당
    - 유지보수가 쉬워짐
4. 알고리즘 독립성
    - 각 전략이 독립적으로 존재
    - 한 전략 수정이 다른 전략에 영향 없음
5. 테스트 용이성
    - 각 전략을 독립적으로 테스트 가능
    - Mock 객체로 쉽게 테스트(OCP)

## 단점

1. 클래스/파일 수 증가
    - 전략마다 클래스(파일)를 만들어야함
    - 간단한 로직에는 오버 엔지니어링
2. 클라이언트가 전략을 알아야 함
    - 사용자가 어떤 전략들이 있는지 알고 선택해야 함
    - 전략 간 차이를 이해해야 함
3. 전략이 적을 때는 비효율적
    - 전략이 2~3개라면 단순 if문이 더 나을 수 있음
    - 복잡도 대비 효과가 적을 수 있음
4. 컨텍스트와 전략 간 데이터 공유 복잡
    - 전략이 컨텍스트의 많은 데이터를 필요로 하면 인터페이스가 복잡해짐
    - 불필요한 데이터까지 전달해야 할 수 있음