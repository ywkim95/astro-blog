---
title: '옵저버 패턴'
description: '디자인 패턴 중 옵저버 패턴에 대해서 간단히 정리한 내용입니다'
pubDate: '2025-10-21'
heroImage: '/placeholder-hero.jpg'
author: '김영우'
tags: ["design pattern", "observer"]
---
# Chapter 1.1.4 옵저버 패턴

책 제목: 면접을 위한 CS 전공지식 노트
주차: 3주차
발표일: 2025년 10월 21일
상태: 진행중
주요 개념: 디자인패턴
챕터/페이지: 1장

# 정의

- 옵저버들이 관찰하고 있는 대상자의 상태가 변화가 있을 때마다 대상자는 직접 목록의 각 관찰자들에게 통지하고, 관찰자들은 알림을 받아 조치를 취하는 행동 디자인 패턴
- 다른 디자인 패턴들과 다르게 **일대다(one-to-many) 의존성**을 가짐
- Pub/Sub(발행/구독) 모델로도 알려져 있음

![observer-pattern.png](/images/observer-pattern.png)

- 대표적으로 구독 시스템, SNS 팔로우 시스템, 메신저 등이 존재한다.

### 구독 시스템 예시

```tsx
interface Observer {
  update(channelName: string, videoTitle: string): void;
}

interface Subject {
  subscribe(observer: Observer): void;
  unsubscribe(observer: Observer): void;
  notifyObservers(videoTitle: string): void;
}

class Subscriber implements Observer {
  private name: string;

  constructor(name: string) {
    this.name = name;
  }

  update(channelName: string, videoTitle: string): void {
    console.log(`[${this.name}] 새 알림: ${channelName}에서 "${videoTitle}" 영상을 업로드했습니다!`);
  }

  getName(): string {
    return this.name;
  }
}

class YoutubeChannel implements Subject {
  private channelName: string;
  private subscribers: Observer[] = [];

  constructor(channelName: string) {
    this.channelName = channelName;
  }

  subscribe(observer: Observer): void {
    if (!this.subscribers.includes(observer)) {
      this.subscribers.push(observer);
      console.log(`✅ ${(observer as Subscriber).getName()}님이 ${this.channelName}을 구독했습니다.`);
    }
  }

  unsubscribe(observer: Observer): void {
    const index = this.subscribers.indexOf(observer);
    if (index > -1) {
      this.subscribers.splice(index, 1);
      console.log(`❌ ${(observer as Subscriber).getName()}님이 ${this.channelName} 구독을 취소했습니다.`);
    }
  }

  notifyObservers(videoTitle: string): void {
    console.log(`\n📢 ${this.channelName}에서 새 영상 업로드!`);
    this.subscribers.forEach(subscriber => {
      subscriber.update(this.channelName, videoTitle);
    });
    console.log('');
  }

  uploadVideo(videoTitle: string): void {
    console.log(`\n🎬 ${this.channelName}에서 "${videoTitle}" 영상을 업로드 중...`);
    this.notifyObservers(videoTitle);
  }

  getSubscriberCount(): number {
    return this.subscribers.length;
  }
}

console.log('=== 유튜브 구독 시스템 ===\n');

const techChannel = new YoutubeChannel('코딩하는펭귄');
const musicChannel = new YoutubeChannel('음악방송국');

const user1 = new Subscriber('철수');
const user2 = new Subscriber('영희');
const user3 = new Subscriber('민수');

techChannel.subscribe(user1);
techChannel.subscribe(user2);
techChannel.subscribe(user3);

musicChannel.subscribe(user1);
musicChannel.subscribe(user3);

console.log(`\n현재 코딩하는펭귄 구독자 수: ${techChannel.getSubscriberCount()}명`);
console.log(`현재 음악방송국 구독자 수: ${musicChannel.getSubscriberCount()}명`);

techChannel.uploadVideo('TypeScript 디자인 패턴 완벽 정리');
musicChannel.uploadVideo('잔잔한 재즈 모음집 10시간');

techChannel.unsubscribe(user2);

techChannel.uploadVideo('React 18 새로운 기능 총정리');
```

## 장점

1. 느슨한 결합 (Loose Coupling)

- Subject와 Observer가 서로 독립적
- Subject는 Observer의 구체적인 구현을 몰라도 됨
- 인터페이스만 알면 되므로 유연함

2. 개방-폐쇄 원칙 (OCP)

- Subject 코드 수정 없이 새로운 Observer 추가 가능
- 새로운 구독자 타입을 자유롭게 추가

3. 런타임에 동적으로 관계 설정

- 실행 중에 구독/구독취소 가능
- 유연한 객체 간 관계 형성

4. 브로드캐스트 통신

- 한 번의 변경으로 여러 객체에 자동 알림
- 일일이 호출할 필요 없음

5. 재사용성

- Subject와 Observer를 독립적으로 재사용 가능
- 다른 프로젝트에서도 활용 가능

6. 상태 변경과 알림의 분리

- 비즈니스 로직과 알림 로직이 분리됨
- 단일 책임 원칙 준수

## 단점

**1. 알림 순서를 보장할 수 없음**

- Observer들이 어떤 순서로 알림 받을지 예측 불가
- 순서에 의존하는 로직이 있으면 문제 발생

**2. 메모리 누수 위험**

- 구독 취소를 안 하면 Observer가 계속 메모리에 남음
- 가비지 컬렉션 되지 않아 메모리 누수

**3. 예상치 못한 업데이트**

- Observer가 많아지면 어떤 Observer가 반응할지 추적 어려움
- 디버깅이 복잡해짐

**4. 성능 저하 가능성**

- Observer가 너무 많으면 알림에 시간이 오래 걸림
- 하나의 변경에 수천 개의 알림이 발생할 수 있음

**5. 순환 의존성 문제**

- Observer가 다시 Subject를 변경하면 무한 루프 가능
- A가 B를 업데이트 → B가 A를 업데이트 → 무한반복

**6. 복잡도 증가**

- 간단한 기능에는 오버엔지니어링
- 직접 호출이 더 명확할 수 있음

**7. Update 메서드가 범용적이면 비효율**

- 모든 변경사항을 하나의 update로 처리하면 불필요한 정보까지 전달
- 구체적인 이벤트 타입이 필요할 수 있음